<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_rotor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-15</depth>
  <persistent>0</persistent>
  <parentName>par_vehicle</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initialize variables
//driver - person who is driving
driver = noone;
//driverImage - image of driver
driverImage = 0;
//driverInput - input of driver
driverInput = 0;
//driverId - id of driver
driverId = noone;
//driverObjectId - id of object of driver
dirverObjectId = 0;
//supplies - driver supplies
supplies = 1;

//passengerAmount
passengerAmount = 0;
//passengers
passengers[0] = self;

//nHealth - car health
nHealth = 100;
//nHealthMax
nHealthMax = nHealth;
//stop animation
image_speed = 0;
//maxAltitude - fastest image speed
maxAltitude = 2;
//chopperSprite - sprite of chopper
chopperSprite = spr_car;
//chopperImage - image of chopper
chopperImage = 0;
//missle - amount of missles
missle = 3;
//missle buffer
alarm[1] = 10;
//maxSpeed
maxSpeed = 4;

//actionInputFreeze
actionInputFreeze = 0;
//actionInputFreezeMax
actionInputFreezeMax = 10;

//nativeDrive - whether or not a native drivable vehicle
nativeDrive = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//missle converter
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>count down timer</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///input
    //driver
    if (script_execute(scr_idExist, driver)) {
        //left, up, right, down, action - keys
        haxis1 = 0;
        vaxis1 = 0;
        actionReleased = false;
        counterReleased = false;
        convertReleased = false;
        
        //axisBuffer - buffer till push starts counting
        axisBuffer = 0.4;
        
        //Player
        switch(driverInput) {
            case 1:
                //input
                input = 0;
                haxis1 = gamepad_axis_value(input, gp_axislh);
                vaxis1 = gamepad_axis_value(input, gp_axislv);
                actionReleased = gamepad_button_check_released(input, gp_face1);
                counterReleased = gamepad_button_check_released(input, gp_face3);
                convertReleased = gamepad_button_check_released(input, gp_face4);
                break;
            case 2:
                //input
                input = 1;
                haxis1 = gamepad_axis_value(input, gp_axislh);
                vaxis1 = gamepad_axis_value(input, gp_axislv);
                actionReleased = gamepad_button_check_released(input, gp_face1);
                counterReleased = gamepad_button_check_released(input, gp_face3);
                convertReleased = gamepad_button_check_released(input, gp_face4);
                break;
            case 3:
                //input
                input = 2;
                haxis1 = gamepad_axis_value(input, gp_axislh);
                vaxis1 = gamepad_axis_value(input, gp_axislv);
                actionReleased = gamepad_button_check_released(input, gp_face1);
                counterReleased = gamepad_button_check_released(input, gp_face3);
                convertReleased = gamepad_button_check_released(input, gp_face4);
                break;
            case 4:
                //input
                input = 3;
                haxis1 = gamepad_axis_value(input, gp_axislh);
                vaxis1 = gamepad_axis_value(input, gp_axislv);
                actionReleased = gamepad_button_check_released(input, gp_face1);
                counterReleased = gamepad_button_check_released(input, gp_face3);
                convertReleased = gamepad_button_check_released(input, gp_face4);
                break;
            case 5:
                //input
                if(keyboard_check(vk_left)) haxis1 = -1;
                if(keyboard_check(vk_right)) haxis1 = 1;
                if(keyboard_check(vk_up)) vaxis1 = -1;
                if(keyboard_check(vk_down)) vaxis1 = 1;
                actionReleased = keyboard_check_pressed(vk_numpad0);
                counterReleased = keyboard_check_pressed(vk_numpad1);
                convertReleased = keyboard_check_pressed(vk_numpad2);
                break;
            case 6:
                //input
                if(keyboard_check(ord("A"))) haxis1 = -1;
                if(keyboard_check(ord("D"))) haxis1 = 1;
                if(keyboard_check(ord("W"))) vaxis1 = -1;
                if(keyboard_check(ord("S"))) vaxis1 = 1;
                actionReleased = keyboard_check_pressed(ord("F"));
                counterReleased = keyboard_check_pressed(ord("G"));
                convertReleased = keyboard_check_pressed(ord("T"));
                break;
            case 7:
                //input
                if(keyboard_check(ord("J"))) haxis1 = -1;
                if(keyboard_check(ord("L"))) haxis1 = 1;
                if(keyboard_check(ord("I"))) vaxis1 = -1;
                if(keyboard_check(ord("K"))) vaxis1 = 1;
                actionReleased = keyboard_check_pressed(186);
                counterReleased = keyboard_check_pressed(188);
                convertReleased = keyboard_check_pressed(219);
                break;
            case 8:
                //input
                if(keyboard_check(vk_left)) haxis1 = -1;
                if(keyboard_check(vk_right)) haxis1 = 1;
                if(keyboard_check(vk_up)) vaxis1 = -1;
                if(keyboard_check(vk_down)) vaxis1 = 1;
                actionReleased = keyboard_check_pressed(vk_numpad3);
                break;
            case 0:
                //input
                if (alarm[0] &lt;= 0) {
                    haxis1 = choose(1, 0, -1);
                    haxis1 = choose(1, 0, -1);
                    action = choose(false, true);
                    alarm[0] = irandom_range(10, 20);
                    }
                break;
            }
        //axis check
        if (haxis1 &lt; axisBuffer and haxis1 &gt; -axisBuffer) haxis1 = 0;
        if (vaxis1 &lt; axisBuffer and vaxis1 &gt; -axisBuffer) vaxis1 = 0;
        //freeze action
        if (actionInputFreeze &gt; 0) {
            actionReleased = false;
            actionInputFreeze--;
            }
        
        //move_speed - acculmative speed
        move_speed = 0.1;
        //maxSpeed - max speed
        maxSpeed = 4
 
        //if in air move
        if (image_speed &gt;= maxAltitude) {
            //Find current hspeed
            hspeed += (haxis1)*move_speed;
            vspeed += (vaxis1)*move_speed;
            dir = script_execute(scr_findDir, hspeed, vspeed, move_speed*2)
            if (dir = 8) dir = chopperImage;
            if !(script_execute(scr_changeDir, dir, chopperImage)) {
                hspeed -= (haxis1)*move_speed;
                vspeed -= (vaxis1)*move_speed;
                }
            
            //Slow down
            if (haxis1 = 0) {
                if (hspeed &gt; move_speed*2) hspeed -= move_speed*2
                else if (hspeed &lt; -move_speed*2) hspeed += move_speed*2
                else hspeed = 0;
                }
            if (vaxis1 = 0) {
                if (vspeed &gt; move_speed*2) vspeed -= move_speed*2
                else if (vspeed &lt; -move_speed*2) vspeed += move_speed*2
                else vspeed = 0;
                }
            
            //keep speed in check
            if (hspeed &gt; maxSpeed) hspeed = maxSpeed;
            if (hspeed &lt; -maxSpeed) hspeed = -maxSpeed;
            if (vspeed &gt; maxSpeed) vspeed = maxSpeed;
            if (vspeed &lt; -maxSpeed) vspeed = -maxSpeed;
            
            //keep in room
            if (x &lt; 0) x = 0;
            else if (x &gt; room_width -32) x = room_width - 32;
            if (y &lt; 0) y = 0;
            else if (y &gt; room_height - 32) y = room_height - 32;
            
            //find dir
            dir = script_execute(scr_findDir, hspeed, vspeed, move_speed*2);
            if (dir &lt; 8 and script_execute(scr_changeDir, dir, chopperImage)) chopperImage = dir;
            
            //convert
            if (convertReleased) {
                //if there is enough supplies convert
                if (supplies &gt; 9 &amp;&amp; alarm[2] &lt; 0) {
                    //add missle
                    missle += 1;
                        
                    //subtract supplys
                    supplies -= 10;
                    
                    //light up
                    alarm[2] = 20;
                    }
                }
            
            //fire missle
            if (counterReleased) {
                //check if there is a missle
                if (missle &gt; 0 &amp;&amp; alarm[1] &lt; 1) {
                    //missleSpeed - speed of missle
                    missleSpeed = 6;
                    //create missle
                    if (chopperImage = 0) {
                        with (instance_create(x + 8, y +8, obj_missle)) {
                            vspeed = -other.missleSpeed;
                            image_index = other.chopperImage;
                            }
                        }
                    if (chopperImage = 1) {
                        with (instance_create(x + 8, y + 8, obj_missle)) {
                            hspeed = other.missleSpeed
                            vspeed = -other.missleSpeed;
                            image_index = other.chopperImage;
                            }
                        }
                    if (chopperImage = 2) {
                        with (instance_create(x + 8, y + 8, obj_missle)) {
                            hspeed = other.missleSpeed
                            image_index = other.chopperImage;
                            }
                        }
                    if (chopperImage = 3) {
                        with (instance_create(x + 8, y + 8, obj_missle)) {
                            hspeed = other.missleSpeed
                            vspeed = other.missleSpeed;
                            image_index = other.chopperImage;
                            }
                        }
                    if (chopperImage = 4) {
                        with (instance_create(x + 8, y + 8, obj_missle)) {
                            vspeed = other.missleSpeed;
                            image_index = other.chopperImage;
                            }
                        }
                    if (chopperImage = 5) {
                        with (instance_create(x + 8, y + 8, obj_missle)) {
                            hspeed = -other.missleSpeed
                            vspeed = other.missleSpeed;
                            image_index = other.chopperImage;
                            }
                        }
                    if (chopperImage = 6) {
                        with (instance_create(x + 8, y + 8, obj_missle)) {
                            hspeed = -other.missleSpeed
                            image_index = other.chopperImage;
                            }
                        }
                    if (chopperImage = 7) {
                        with (instance_create(x + 8, y + 8, obj_missle)) {
                            hspeed = -other.missleSpeed
                            vspeed = -other.missleSpeed;
                            image_index = other.chopperImage;
                            }
                        }
                    //set missle
                    missle -= 1;
                    //reset buffer
                    alarm[1] = 10;
                    }
                }
            }
        else {  //take off
            if (haxis1 != 0 || vaxis1 != 0) image_speed += 0.01;
            else if (image_speed &gt;= 0.02) image_speed -= 0.02;
            }
        
        //leave car
        if (actionReleased) {
            //check if landing spot is free
            if (place_free(x, y) &amp;&amp; hspeed = 0 &amp;&amp; vspeed = 0) {
                //drop altitidue
                if (image_speed &gt;= 0.02) image_speed -= 0.02;
                //if near ground drop player
                if (image_speed &lt; maxAltitude/3) event_user(1);
                }
            }
        }
    else {
        //stop rotor
        if (image_speed &gt;= 0.02) image_speed -= 0.02;
        
        //move_speed - acculmative speed
        move_speed = 0.1;
        
        //stop
        if (hspeed &gt; move_speed*2) hspeed -= move_speed*2
        else if (hspeed &lt; -move_speed*2) hspeed += move_speed*2
        else hspeed = 0;
        if (vspeed &gt; move_speed*2) vspeed -= move_speed*2
        else if (vspeed &lt; -move_speed*2) vspeed += move_speed*2
        else vspeed = 0;
        
        //if on helipad replace missles
        if (place_meeting(x, y, obj_helipad)) {
            if (missle &lt; 3) missle = 3;
            }
        }

//collide with explosion
    if (instance_place(x, y, explosion)) nHealth -= 20;
    if (instance_place(x, y, MissleExplosion)) nHealth -= 7;
    if (instance_place(x, y, obj_explosionCar)) nHealth -= 1;
    if (instance_place(x, y, NukeExplosion)) nHealth -= 40;
    with (instance_place(x, y, BigBomb90)) {
        other.nHealth -= 3;
        //destroy other
        instance_destroy();
        }
    with (instance_place(x, y, BombPiece)) {
        other.nHealth -= 1;
        //destroy other
        instance_destroy();
        }

//damage 
    if (nHealth &lt; 50) chopperSprite = spr_chopperDamaged;
    else chopperSprite = spr_chopper;

//die
    if (nHealth &lt; 1) {
        //drop driver
        event_user(1);
        //drop passenger
        event_user(3);
        
        //create explosion
        instance_create(x, y, obj_explosionCar);
        //destroy self
        instance_destroy();
        }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///update driver position
    //driver
    if (script_execute(scr_idExist, driver)) {
        driver.x = x+16;
        driver.y = y+16;
        }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///change driver
if (script_execute(scr_idExist, driver)) {
    //activate driver
    driver.active = true;
    
        //actionInputFreeze
    if !(driver.civilian) {
        driver.actionInputFreeze = driver.actionInputFreezeMax;
        }
        
    //reset driver
    driver = noone;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///change drivers
    //set supplies
    supplies = driver.supplyblue;
    
    //set image
    driverImage = driver.sprite_index;
    //set ids
    dirverId = driver.id
    dirverObjectId = driver.object_index
    //set input
    driverInput = driver.playerInput;
    //freeze action input
    actionInputFreeze = actionInputFreezeMax;
    //deactivate driver
    driver.active = false;
    //if civilian start driving
    if (driver.civilian) alarm[0] = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw HUD
var portHeight = display_get_gui_height();
//draw set up
draw_set_font(fnt_HUD);
draw_set_color(c_white);

//if driver exist
if (script_execute(scr_idExist, driver)) {
    //draw HUD bar
    if (driverInput != 0) {
        if (alarm[2] &lt;= 0) draw_sprite_ext(spr_chopperHUDBar, 0, driver.playerId*80*portScale, portHeight - 36*portScale, portScale, portScale, 0, c_white, 1);
        else draw_sprite_ext(spr_chopperHUDBar, 1, driver.playerId*80*portScale, portHeight - 36*portScale, portScale, portScale, 0, c_white, 1);
        //sep 100 - so new line wont be seen
        var sep = 100*portScale;
        draw_text_ext(driver.playerId*80*portScale+2*portScale, portHeight - 36*portScale, driver.nickname, sep, 78*portScale);
        //draw supplies
        draw_text(driver.playerId*80*portScale+17*portScale, portHeight - 20*portScale, supplies);
        //draw missles
        draw_text(driver.playerId*80*portScale+64*portScale, portHeight - 20*portScale, missle);
        //draw health bar
        draw_healthbar(driver.playerId*80*portScale+2*portScale, portHeight - 19*portScale, driver.playerId*80*portScale+78*portScale, portHeight - 17*portScale, driver.nHealth, c_black, c_red, c_green, 180, true, false);
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//set color
draw_set_color(c_white);

//if driver exist
draw_healthbar(x, y + 32, x + 32, y + 30, nHealth, c_black, c_red, c_green, 180, true, false);

//draw chopper
draw_sprite(chopperSprite, chopperImage, x, y);
//draw driver
if (script_execute(scr_idExist, driver)) {
    if (chopperImage = 0) draw_sprite_ext(driverImage, driver.image_index, x + 9+8, y + 4+8, 1, 1, 90, c_white, 1);
    if (chopperImage = 1) draw_sprite_ext(driverImage, driver.image_index, x + 13+8, y + 4+8, 1, 1, 45, c_white, 1);
    if (chopperImage = 2) draw_sprite_ext(driverImage, driver.image_index, x + 16+8, y + 10+8, 1, 1, 0, c_white, 1);
    if (chopperImage = 3) draw_sprite_ext(driverImage, driver.image_index, x + 14+8, y + 13+8, 1, 1, 315, c_white, 1);
    if (chopperImage = 4) draw_sprite_ext(driverImage, driver.image_index, x + 9+8, y + 15+8, 1, 1, 270, c_white, 1);
    if (chopperImage = 5) draw_sprite_ext(driverImage, driver.image_index, x + 5+8, y + 13+8, 1, 1, 225, c_white, 1);
    if (chopperImage = 6) draw_sprite_ext(driverImage, driver.image_index, x + 4+8, y + 10+8, 1, 1, 180, c_white, 1);
    if (chopperImage = 7) draw_sprite_ext(driverImage, driver.image_index, x + 5+8, y + 4+8, 1, 1, 135, c_white, 1);
    }

//draw rotors
draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
